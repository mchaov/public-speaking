<!DOCTYPE html>
<html>
	<head></head>
	<body>
	
		<script>
			
// сетъп, коментиран в 15102016-bubble.html
Array.prototype.swap = function(i, j){
	var t = this[i];
	this[i] = this[j];
	this[j] = t;
	return this;
}

var arr1 = [2, 5, 8, 7, 6, 9, 1, 3, 4, 0, 12, 15, 18, 17, 16, 19, 11, 13, 14, 10, 22, 25, 28, 27, 26, 29, 21, 23, 24, 20];
var arr2 = [2, 5, 8, 7, 6, 9, 1, 3, 4, 0, 12, 15, 18, 17, 16, 19, 11, 13, 14, 10, 22, 25, 28, 27, 26, 29, 21, 23, 24, 20];
var arr3 = [2, 5, 8, 7, 6, 9, 1, 3, 4, 0, 12, 15, 18, 17, 16, 19, 11, 13, 14, 10, 22, 25, 28, 27, 26, 29, 21, 23, 24, 20];

/////////////////////////////////////
// Бързо сортиране - опростена версия
/////////////////////////////////////
// разделяй и владей
// функция определяща главният елемент
// приема:
// arr	->	Масив
// l	->	Число, ляв индекс в масива
// r	->	Число, десен индекс в масива
function partition(arr, l, r){
	var p,	// точка на делене
		i,	// итератор
		x;	// кеширан последен елемент
	
	p = l - 1;		// ляв индекс - 1
	x = arr[r];		// елемент на десен индекс
	
	// итератор
	// започваме да итерираме от l
	// докато стигнем до r
	for(i = l; i <= r; i++){
		// сравняваме елементът от итерацията
		// с кешираният главен елемент
		if(arr[i] <= x){
			// вземаме следващият елемент
			p++; // важно е да се отбележи че това променя "p"
				 // и за следващата операция, поради тази причина
				 // не извикваме arr.swap(p + 1, i);
			
			// разменяме двата елемента
			arr.swap(p, i);
		}
	}
	
	// ако стигнем до края, минаваме един елемент назад
	// и връщаме новата точка на делене
	if(p === r) p--;
	
	// нова точка на делене
	return p;
}

// Бързо сортиране
// приема:
// arr	->	Масив
// l	->	Число, индекс на 1ви елемен -> 0
// r	->	Число, краен елемент на масива -> arr.length - 1
function quickSort(arr, l, r){
	var p;	// декларираме точка на делене
	
	if (l < r){ // сравняваме индексите
		p = partition(arr, l, r);	// извикваме изчислението на точка на делене
		quickSort(arr, l, p);		// извикваме за лявата половина
		quickSort(arr, p + 1, r);	// извикваме за дясната половина
	}
}

/////////////////////////////////////
// Бързо сортиране на Хор
/////////////////////////////////////
// оптимизирана алтернатива на бързото сортиране
// приема:
// arr	->	Масив
// l	->	Число, индекс на 1ви елемен -> 0
// r	->	Число, краен елемент на масива -> arr.length - 1
function quickSort2(arr, l, r){
	var i,	// итератор 1
		j,	// итератор 2
		x;	// кеширан елемент
	
	i = l;		// кешираме лява позиция
	j = r;		// кешираме дясна позиция
	x = arr[r];	// кешираме последният елемент
	
	// докато...
	do {
		// ...стойността на последният елемент е по-голяма
		// от стойността на този в текущата итерацията
		// вземи следващият
		while(x > arr[i]) i++; // ляво на дясно
		
		// ...стойността на последният елемент е по-малка
		// от стойността на този в текущата итерацията
		// вземи следващият
		while(x < arr[j]) j--; // дясно на ляво
		
		// при намиране на елементи
		// правим сравнение на индексите
		// за да разберем дали са от ляво или дясно
		if(i <= j){
			arr.swap(i, j);	// разменяме елементите на тези индекси
			i++;			// вземаме следващият индекс от ляво на дясно
			j--;			// вземаме следващият индекс от дясно на ляво
		}
	} while ( j >= i);		// повтори докато десният елемент е по-голям или равен на левият
	
	// извиквай рекурсивно за всяко намерено разделяне
	if(j > l){
		quickSort2(arr, l, j); // извикай за по-малките от главната точка
	}
	if(i < r){
		quickSort2(arr, i, r); // извикай за по-големите от главната точка
	}
	
	return arr;
}


/*
function average(arr){
	return arr.reduce(function(a, b) {
		return a + b;
	}) / arr.length;
}

function bench(number, callback, arrgs){
	var result = [], i, p;
	for(i = 0; i < number; i++){
		p = performance.now();
		callback.apply(null, arrgs);
		result.push(performance.now() - p);
	}
	return result;
}
*/


// тест на производителността
var p = performance.now();

console.log('quickSort');
p = performance.now();
quickSort(arr1, 0, arr1.length - 1);
console.log(performance.now() - p);

console.log('quickSort optimized');
p = performance.now();
quickSort2(arr2, 0, arr2.length - 1);
console.log(performance.now() - p);

console.log('native');
p = performance.now();
arr3.sort(); // вграден сорт метод
console.log(performance.now() - p);
	
			
		</script>
	</body>
</html>